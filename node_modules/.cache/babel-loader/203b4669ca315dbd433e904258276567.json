{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/cristina/Desktop/BERKELEY/react-portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral([\"\\n    <div class=\\\"overlay\\\">\\n      <svg id=\\\"svg\\\"></svg>\\n    </div>\\n    \"]);\n\n  _templateObject2 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n    :host {\\n      display: inline-block;\\n      position: relative;\\n      width: 300px;\\n      height: 40px;\\n      outline: none;\\n      box-sizing: border-box;\\n      opacity: 0;\\n    }\\n\\n    :host(.wired-rendered) {\\n      opacity: 1;\\n    }\\n  \\n    :host(.wired-disabled) {\\n      opacity: 0.45 !important;\\n      cursor: default;\\n      pointer-events: none;\\n      background: rgba(0, 0, 0, 0.07);\\n      border-radius: 5px;\\n    }\\n  \\n    :host(.wired-disabled) .knob {\\n      pointer-events: none !important;\\n    }\\n  \\n    :host(:focus) .knob {\\n      cursor: move;\\n      stroke: var(--wired-slider-knob-outline-color, #000);\\n      fill-opacity: 0.8;\\n    }\\n  \\n    .overlay {\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      right: 0;\\n      bottom: 0;\\n      pointer-events: none;\\n    }\\n  \\n    svg {\\n      display: block;\\n    }\\n  \\n    path {\\n      stroke-width: 0.7;\\n      fill: transparent;\\n    }\\n  \\n    .knob {\\n      pointer-events: auto;\\n      fill: var(--wired-slider-knob-zero-color, gray);\\n      stroke: var(--wired-slider-knob-zero-color, gray);\\n      transition: transform 0.15s ease;\\n      cursor: pointer;\\n    }\\n  \\n    .hasValue {\\n      fill: var(--wired-slider-knob-color, rgb(51, 103, 214));\\n      stroke: var(--wired-slider-knob-color, rgb(51, 103, 214));\\n    }\\n  \\n    .bar {\\n      stroke: var(--wired-slider-bar-color, rgb(0, 0, 0));\\n    }\\n    \"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nimport { WiredBase, customElement, property, html, css } from 'wired-lib/lib/wired-base';\nimport { line, svgNode, ellipse } from 'wired-lib';\nimport { addListener } from '@polymer/polymer/lib/utils/gestures.js';\nlet WiredSlider = class WiredSlider extends WiredBase {\n  constructor() {\n    super(...arguments);\n    this._value = 0;\n    this.min = 0;\n    this.max = 100;\n    this.knobradius = 10;\n    this.disabled = false;\n    this.step = 1;\n    this.barWidth = 0;\n    this.intermediateValue = this.min;\n    this.pct = 0;\n    this.startx = 0;\n    this.dragging = false;\n  }\n\n  static get styles() {\n    return css(_templateObject());\n  }\n\n  render() {\n    return html(_templateObject2());\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(v) {\n    this.setValue(v, true);\n  }\n\n  refreshDisabledState() {\n    if (this.disabled) {\n      this.classList.add('wired-disabled');\n    } else {\n      this.classList.remove('wired-disabled');\n    }\n\n    this.tabIndex = this.disabled ? -1 : +(this.getAttribute('tabindex') || 0);\n  }\n\n  firstUpdated() {\n    const svg = this.shadowRoot.getElementById('svg');\n\n    while (svg.hasChildNodes()) {\n      svg.removeChild(svg.lastChild);\n    }\n\n    const s = this.getBoundingClientRect();\n    svg.setAttribute('width', \"\".concat(s.width));\n    svg.setAttribute('height', \"\".concat(s.height));\n    const radius = this.knobradius || 10;\n    this.barWidth = s.width - 2 * radius;\n    this.bar = line(svg, radius, s.height / 2, s.width - radius, s.height / 2);\n    this.bar.classList.add('bar');\n    this.knobGroup = svgNode('g');\n    svg.appendChild(this.knobGroup);\n    this.knob = ellipse(this.knobGroup, radius, s.height / 2, radius * 2, radius * 2);\n    this.knob.classList.add('knob');\n    this.onValueChange();\n    this.classList.add('wired-rendered'); // aria\n\n    this.setAttribute('role', 'slider');\n    this.setAttribute('aria-valuemax', \"\".concat(this.max));\n    this.setAttribute('aria-valuemin', \"\".concat(this.min));\n    this.setAriaValue(); // attach events\n\n    addListener(this.knob, 'down', event => {\n      if (!this.disabled) {\n        this.knobdown(event);\n      }\n    });\n    addListener(this.knob, 'up', () => {\n      if (!this.disabled) {\n        this.resetKnob();\n      }\n    });\n    addListener(this.knob, 'track', event => {\n      if (!this.disabled) {\n        this.onTrack(event);\n      }\n    });\n    this.addEventListener('keydown', event => {\n      switch (event.keyCode) {\n        case 38:\n        case 39:\n          this.incremenent();\n          break;\n\n        case 37:\n        case 40:\n          this.decrement();\n          break;\n\n        case 36:\n          this.setValue(this.min);\n          break;\n\n        case 35:\n          this.setValue(this.max);\n          break;\n      }\n    });\n  }\n\n  updated(changed) {\n    if (changed.has('disabled')) {\n      this.refreshDisabledState();\n    }\n  }\n\n  setAriaValue() {\n    this.setAttribute('aria-valuenow', \"\".concat(this.value));\n  }\n\n  setValue(v, skipEvent = false) {\n    this._value = v;\n    this.setAriaValue();\n    this.onValueChange();\n\n    if (!skipEvent) {\n      this.fireEvent('change', {\n        value: this.intermediateValue\n      });\n    }\n  }\n\n  incremenent() {\n    const newValue = Math.min(this.max, Math.round(this.value + this.step));\n\n    if (newValue !== this.value) {\n      this.setValue(newValue);\n    }\n  }\n\n  decrement() {\n    const newValue = Math.max(this.min, Math.round(this.value - this.step));\n\n    if (newValue !== this.value) {\n      this.setValue(newValue);\n    }\n  }\n\n  onValueChange() {\n    if (!this.knob) {\n      return;\n    }\n\n    let pct = 0;\n\n    if (this.max > this.min) {\n      pct = Math.min(1, Math.max((this.value - this.min) / (this.max - this.min), 0));\n    }\n\n    this.pct = pct;\n\n    if (pct) {\n      this.knob.classList.add('hasValue');\n    } else {\n      this.knob.classList.remove('hasValue');\n    }\n\n    const knobOffset = pct * this.barWidth;\n    this.knobGroup.style.transform = \"translateX(\".concat(Math.round(knobOffset), \"px)\");\n  }\n\n  knobdown(event) {\n    this.knobExpand(true);\n    event.preventDefault();\n    this.focus();\n  }\n\n  resetKnob() {\n    this.knobExpand(false);\n  }\n\n  knobExpand(value) {\n    if (this.knob) {\n      if (value) {\n        this.knob.classList.add('expanded');\n      } else {\n        this.knob.classList.remove('expanded');\n      }\n    }\n  }\n\n  onTrack(event) {\n    event.stopPropagation();\n\n    switch (event.detail.state) {\n      case 'start':\n        this.trackStart();\n        break;\n\n      case 'track':\n        this.trackX(event);\n        break;\n\n      case 'end':\n        this.trackEnd();\n        break;\n    }\n  }\n\n  trackStart() {\n    this.intermediateValue = this.value;\n    this.startx = this.pct * this.barWidth;\n    this.dragging = true;\n  }\n\n  trackX(event) {\n    if (!this.dragging) {\n      this.trackStart();\n    }\n\n    const dx = event.detail.dx || 0;\n    const newX = Math.max(Math.min(this.startx + dx, this.barWidth), 0);\n    this.knobGroup.style.transform = \"translateX(\".concat(Math.round(newX), \"px)\");\n    const newPct = newX / this.barWidth;\n    this.intermediateValue = this.min + newPct * (this.max - this.min);\n  }\n\n  trackEnd() {\n    this.dragging = false;\n    this.resetKnob();\n    this.setValue(this.intermediateValue);\n    this.pct = (this.value - this.min) / (this.max - this.min);\n  }\n\n};\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Object)], WiredSlider.prototype, \"_value\", void 0);\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Object)], WiredSlider.prototype, \"min\", void 0);\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Object)], WiredSlider.prototype, \"max\", void 0);\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Object)], WiredSlider.prototype, \"knobradius\", void 0);\n\n__decorate([property({\n  type: Boolean,\n  reflect: true\n}), __metadata(\"design:type\", Object)], WiredSlider.prototype, \"disabled\", void 0);\n\nWiredSlider = __decorate([customElement('wired-slider')], WiredSlider);\nexport { WiredSlider };","map":null,"metadata":{},"sourceType":"module"}