{"ast":null,"code":"export class Segment {\n  constructor(p1, p2) {\n    this.xi = Number.MAX_VALUE;\n    this.yi = Number.MAX_VALUE;\n    this.px1 = p1[0];\n    this.py1 = p1[1];\n    this.px2 = p2[0];\n    this.py2 = p2[1];\n    this.a = this.py2 - this.py1;\n    this.b = this.px1 - this.px2;\n    this.c = this.px2 * this.py1 - this.px1 * this.py2;\n    this._undefined = this.a === 0 && this.b === 0 && this.c === 0;\n  }\n\n  isUndefined() {\n    return this._undefined;\n  }\n\n  intersects(otherSegment) {\n    if (this.isUndefined() || otherSegment.isUndefined()) {\n      return false;\n    }\n\n    let grad1 = Number.MAX_VALUE;\n    let grad2 = Number.MAX_VALUE;\n    let int1 = 0,\n        int2 = 0;\n    const a = this.a,\n          b = this.b,\n          c = this.c;\n\n    if (Math.abs(b) > 0.00001) {\n      grad1 = -a / b;\n      int1 = -c / b;\n    }\n\n    if (Math.abs(otherSegment.b) > 0.00001) {\n      grad2 = -otherSegment.a / otherSegment.b;\n      int2 = -otherSegment.c / otherSegment.b;\n    }\n\n    if (grad1 === Number.MAX_VALUE) {\n      if (grad2 === Number.MAX_VALUE) {\n        if (-c / a !== -otherSegment.c / otherSegment.a) {\n          return false;\n        }\n\n        if (this.py1 >= Math.min(otherSegment.py1, otherSegment.py2) && this.py1 <= Math.max(otherSegment.py1, otherSegment.py2)) {\n          this.xi = this.px1;\n          this.yi = this.py1;\n          return true;\n        }\n\n        if (this.py2 >= Math.min(otherSegment.py1, otherSegment.py2) && this.py2 <= Math.max(otherSegment.py1, otherSegment.py2)) {\n          this.xi = this.px2;\n          this.yi = this.py2;\n          return true;\n        }\n\n        return false;\n      }\n\n      this.xi = this.px1;\n      this.yi = grad2 * this.xi + int2;\n\n      if ((this.py1 - this.yi) * (this.yi - this.py2) < -0.00001 || (otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001) {\n        return false;\n      }\n\n      if (Math.abs(otherSegment.a) < 0.00001) {\n        if ((otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return true;\n    }\n\n    if (grad2 === Number.MAX_VALUE) {\n      this.xi = otherSegment.px1;\n      this.yi = grad1 * this.xi + int1;\n\n      if ((otherSegment.py1 - this.yi) * (this.yi - otherSegment.py2) < -0.00001 || (this.py1 - this.yi) * (this.yi - this.py2) < -0.00001) {\n        return false;\n      }\n\n      if (Math.abs(a) < 0.00001) {\n        if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return true;\n    }\n\n    if (grad1 === grad2) {\n      if (int1 !== int2) {\n        return false;\n      }\n\n      if (this.px1 >= Math.min(otherSegment.px1, otherSegment.px2) && this.px1 <= Math.max(otherSegment.py1, otherSegment.py2)) {\n        this.xi = this.px1;\n        this.yi = this.py1;\n        return true;\n      }\n\n      if (this.px2 >= Math.min(otherSegment.px1, otherSegment.px2) && this.px2 <= Math.max(otherSegment.px1, otherSegment.px2)) {\n        this.xi = this.px2;\n        this.yi = this.py2;\n        return true;\n      }\n\n      return false;\n    }\n\n    this.xi = (int2 - int1) / (grad1 - grad2);\n    this.yi = grad1 * this.xi + int1;\n\n    if ((this.px1 - this.xi) * (this.xi - this.px2) < -0.00001 || (otherSegment.px1 - this.xi) * (this.xi - otherSegment.px2) < -0.00001) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\nexport function linerIntersection(l1, l2) {\n  const a1 = l1[1][1] - l1[0][1];\n  const b1 = l1[0][0] - l1[1][0];\n  const c1 = a1 * l1[0][0] + b1 * l1[0][1];\n  const a2 = l2[1][1] - l2[0][1];\n  const b2 = l2[0][0] - l2[1][0];\n  const c2 = a2 * l2[0][0] + b2 * l2[0][1];\n  const determinant = a1 * b2 - a2 * b1;\n\n  if (determinant) {\n    return [Math.round((b2 * c1 - b1 * c2) / determinant), Math.round((a1 * c2 - a2 * c1) / determinant)];\n  }\n\n  return null;\n}\nexport function centroid(points) {\n  let area = 0,\n      cx = 0,\n      cy = 0;\n\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    const next = i === points.length - 1 ? points[0] : points[i + 1];\n    area += p[0] * next[1] - next[0] * p[1];\n  }\n\n  area = area / 2;\n\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    const next = i === points.length - 1 ? points[0] : points[i + 1];\n    cx += (p[0] + next[0]) * (p[0] * next[1] - next[0] * p[1]);\n    cy += (p[1] + next[1]) * (p[0] * next[1] - next[0] * p[1]);\n  }\n\n  return [cx / (6 * area), cy / (6 * area)];\n}","map":null,"metadata":{},"sourceType":"module"}