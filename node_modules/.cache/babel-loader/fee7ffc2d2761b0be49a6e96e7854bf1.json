{"ast":null,"code":"import { hachureLinesForPolygon, hachureLinesForEllipse } from 'roughjs/bin/fillers/filler-utils';\nconst __maxRandomnessOffset = 2;\nconst __roughness = 1;\nconst __bowing = 0.85;\nconst __curveTightness = 0;\nconst __curveStepCount = 9;\n\nclass WiresPath {\n  constructor() {\n    this.p = '';\n  }\n\n  get value() {\n    return this.p.trim();\n  }\n\n  moveTo(x, y) {\n    this.p = \"\".concat(this.p, \"M \").concat(x, \" \").concat(y, \" \");\n  }\n\n  bcurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    this.p = \"\".concat(this.p, \"C \").concat(cp1x, \" \").concat(cp1y, \", \").concat(cp2x, \" \").concat(cp2y, \", \").concat(x, \" \").concat(y, \" \");\n  }\n\n}\n\nexport function svgNode(tagName, attributes) {\n  const n = document.createElementNS('http://www.w3.org/2000/svg', tagName);\n\n  if (attributes) {\n    for (const p in attributes) {\n      n.setAttributeNS(null, p, attributes[p]);\n    }\n  }\n\n  return n;\n}\n\nfunction _getOffset(min, max) {\n  return __roughness * (Math.random() * (max - min) + min);\n}\n\nfunction _line(x1, y1, x2, y2, existingPath) {\n  const lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\n  let offset = __maxRandomnessOffset || 0;\n\n  if (offset * offset * 100 > lengthSq) {\n    offset = Math.sqrt(lengthSq) / 10;\n  }\n\n  const halfOffset = offset / 2;\n  const divergePoint = 0.2 + Math.random() * 0.2;\n  let midDispX = __bowing * __maxRandomnessOffset * (y2 - y1) / 200;\n  let midDispY = __bowing * __maxRandomnessOffset * (x1 - x2) / 200;\n  midDispX = _getOffset(-midDispX, midDispX);\n  midDispY = _getOffset(-midDispY, midDispY);\n  const path = existingPath || new WiresPath();\n  path.moveTo(x1 + _getOffset(-offset, offset), y1 + _getOffset(-offset, offset));\n  path.bcurveTo(midDispX + x1 + (x2 - x1) * divergePoint + _getOffset(-offset, offset), midDispY + y1 + (y2 - y1) * divergePoint + _getOffset(-offset, offset), midDispX + x1 + 2 * (x2 - x1) * divergePoint + _getOffset(-offset, offset), midDispY + y1 + 2 * (y2 - y1) * divergePoint + _getOffset(-offset, offset), x2 + _getOffset(-offset, offset), y2 + _getOffset(-offset, offset));\n  path.moveTo(x1 + _getOffset(-halfOffset, halfOffset), y1 + _getOffset(-halfOffset, halfOffset));\n  path.bcurveTo(midDispX + x1 + (x2 - x1) * divergePoint + _getOffset(-halfOffset, halfOffset), midDispY + y1 + (y2 - y1) * divergePoint + _getOffset(-halfOffset, halfOffset), midDispX + x1 + 2 * (x2 - x1) * divergePoint + _getOffset(-halfOffset, halfOffset), midDispY + y1 + 2 * (y2 - y1) * divergePoint + _getOffset(-halfOffset, halfOffset), x2 + _getOffset(-halfOffset, halfOffset), y2 + _getOffset(-halfOffset, halfOffset));\n  return path;\n}\n\nfunction _continuousLine(x1, y1, x2, y2, move = false, overwrite = false, path) {\n  path = path || new WiresPath();\n  const lengthSq = Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2);\n  let offset = __maxRandomnessOffset || 0;\n\n  if (offset * offset * 100 > lengthSq) {\n    offset = Math.sqrt(lengthSq) / 10;\n  }\n\n  const halfOffset = offset / 2;\n  const divergePoint = 0.2 + Math.random() * 0.2;\n  let midDispX = __bowing * __maxRandomnessOffset * (y2 - y1) / 200;\n  let midDispY = __bowing * __maxRandomnessOffset * (x1 - x2) / 200;\n  midDispX = _getOffset(-midDispX, midDispX);\n  midDispY = _getOffset(-midDispY, midDispY);\n\n  if (move) {\n    path.moveTo(x1 + _getOffset(-offset, offset), y1 + _getOffset(-offset, offset));\n  }\n\n  if (!overwrite) {\n    path.bcurveTo(midDispX + x1 + (x2 - x1) * divergePoint + _getOffset(-offset, offset), midDispY + y1 + (y2 - y1) * divergePoint + _getOffset(-offset, offset), midDispX + x1 + 2 * (x2 - x1) * divergePoint + _getOffset(-offset, offset), midDispY + y1 + 2 * (y2 - y1) * divergePoint + _getOffset(-offset, offset), x2 + _getOffset(-offset, offset), y2 + _getOffset(-offset, offset));\n  } else {\n    path.bcurveTo(midDispX + x1 + (x2 - x1) * divergePoint + _getOffset(-halfOffset, halfOffset), midDispY + y1 + (y2 - y1) * divergePoint + _getOffset(-halfOffset, halfOffset), midDispX + x1 + 2 * (x2 - x1) * divergePoint + _getOffset(-halfOffset, halfOffset), midDispY + y1 + 2 * (y2 - y1) * divergePoint + _getOffset(-halfOffset, halfOffset), x2 + _getOffset(-halfOffset, halfOffset), y2 + _getOffset(-halfOffset, halfOffset));\n  }\n\n  return path;\n}\n\nfunction _curve(vertArray, existingPath) {\n  const vertArrayLength = vertArray.length;\n  let path = existingPath || new WiresPath();\n\n  if (vertArrayLength > 3) {\n    const b = [];\n    const s = 1 - __curveTightness;\n    path.moveTo(vertArray[1][0], vertArray[1][1]);\n\n    for (let i = 1; i + 2 < vertArrayLength; i++) {\n      const cachedVertArray = vertArray[i];\n      b[0] = [cachedVertArray[0], cachedVertArray[1]];\n      b[1] = [cachedVertArray[0] + (s * vertArray[i + 1][0] - s * vertArray[i - 1][0]) / 6, cachedVertArray[1] + (s * vertArray[i + 1][1] - s * vertArray[i - 1][1]) / 6];\n      b[2] = [vertArray[i + 1][0] + (s * vertArray[i][0] - s * vertArray[i + 2][0]) / 6, vertArray[i + 1][1] + (s * vertArray[i][1] - s * vertArray[i + 2][1]) / 6];\n      b[3] = [vertArray[i + 1][0], vertArray[i + 1][1]];\n      path.bcurveTo(b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]);\n    }\n  } else if (vertArrayLength === 3) {\n    path.moveTo(vertArray[0][0], vertArray[0][1]);\n    path.bcurveTo(vertArray[1][0], vertArray[1][1], vertArray[2][0], vertArray[2][1], vertArray[2][0], vertArray[2][1]);\n  } else if (vertArrayLength === 2) {\n    path = _line(vertArray[0][0], vertArray[0][1], vertArray[1][0], vertArray[1][1], path);\n  }\n\n  return path;\n}\n\nfunction _ellipse(ellipseInc, cx, cy, rx, ry, offset, overlap, existingPath) {\n  const radOffset = _getOffset(-0.5, 0.5) - Math.PI / 2;\n  const points = [];\n  points.push([_getOffset(-offset, offset) + cx + 0.9 * rx * Math.cos(radOffset - ellipseInc), _getOffset(-offset, offset) + cy + 0.9 * ry * Math.sin(radOffset - ellipseInc)]);\n\n  for (let angle = radOffset; angle < Math.PI * 2 + radOffset - 0.01; angle = angle + ellipseInc) {\n    points.push([_getOffset(-offset, offset) + cx + rx * Math.cos(angle), _getOffset(-offset, offset) + cy + ry * Math.sin(angle)]);\n  }\n\n  points.push([_getOffset(-offset, offset) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5), _getOffset(-offset, offset) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)]);\n  points.push([_getOffset(-offset, offset) + cx + 0.98 * rx * Math.cos(radOffset + overlap), _getOffset(-offset, offset) + cy + 0.98 * ry * Math.sin(radOffset + overlap)]);\n  points.push([_getOffset(-offset, offset) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5), _getOffset(-offset, offset) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)]);\n  return _curve(points, existingPath);\n}\n\nexport function line(parent, x1, y1, x2, y2) {\n  const path = _line(x1, y1, x2, y2);\n\n  const node = svgNode('path', {\n    d: path.value\n  });\n  parent.appendChild(node);\n  return node;\n}\nexport function rectangle(parent, x, y, width, height) {\n  x = x + 2;\n  y = y + 2;\n  width = width - 4;\n  height = height - 4;\n\n  let path = _line(x, y, x + width, y);\n\n  path = _line(x + width, y, x + width, y + height, path);\n  path = _line(x + width, y + height, x, y + height, path);\n  path = _line(x, y + height, x, y, path);\n  const node = svgNode('path', {\n    d: path.value\n  });\n  parent.appendChild(node);\n  return node;\n}\nexport function polygon(parent, vertices) {\n  let path;\n  const vCount = vertices.length;\n\n  if (vCount > 2) {\n    for (let i = 0; i < 2; i++) {\n      let move = true;\n\n      for (let i = 1; i < vCount; i++) {\n        path = _continuousLine(vertices[i - 1][0], vertices[i - 1][1], vertices[i][0], vertices[i][1], move, i > 0, path);\n        move = false;\n      }\n\n      path = _continuousLine(vertices[vCount - 1][0], vertices[vCount - 1][1], vertices[0][0], vertices[0][1], move, i > 0, path);\n    }\n  } else if (vCount === 2) {\n    path = _line(vertices[0][0], vertices[0][1], vertices[1][0], vertices[1][1]);\n  } else {\n    path = new WiresPath();\n  }\n\n  const node = svgNode('path', {\n    d: path.value\n  });\n  parent.appendChild(node);\n  return node;\n}\nexport function ellipse(parent, x, y, width, height) {\n  width = Math.max(width > 10 ? width - 4 : width - 1, 1);\n  height = Math.max(height > 10 ? height - 4 : height - 1, 1);\n  const ellipseInc = Math.PI * 2 / __curveStepCount;\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += _getOffset(-rx * 0.05, rx * 0.05);\n  ry += _getOffset(-ry * 0.05, ry * 0.05);\n\n  let path = _ellipse(ellipseInc, x, y, rx, ry, 1, ellipseInc * _getOffset(0.1, _getOffset(0.4, 1)));\n\n  path = _ellipse(ellipseInc, x, y, rx, ry, 1.5, 0, path);\n  const node = svgNode('path', {\n    d: path.value\n  });\n  parent.appendChild(node);\n  return node;\n}\n\nfunction renderHachureLines(lines) {\n  const gNode = svgNode('g');\n  let prevPoint = null;\n  lines.forEach(l => {\n    line(gNode, l[0][0], l[0][1], l[1][0], l[1][1]);\n\n    if (prevPoint) {\n      line(gNode, prevPoint[0], prevPoint[1], l[0][0], l[0][1]);\n    }\n\n    prevPoint = l[1];\n  });\n  return gNode;\n}\n\nconst options = {\n  bowing: __bowing,\n  curveStepCount: __curveStepCount,\n  curveTightness: __curveTightness,\n  dashGap: 0,\n  dashOffset: 0,\n  fill: '#000',\n  fillStyle: 'hachure',\n  fillWeight: 1,\n  hachureAngle: -41,\n  hachureGap: 5,\n  maxRandomnessOffset: __maxRandomnessOffset,\n  roughness: __roughness,\n  simplification: 1,\n  stroke: '#000',\n  strokeWidth: 2,\n  zigzagOffset: 0\n};\nexport function hachureFill(points) {\n  const lines = hachureLinesForPolygon(points, options);\n  return renderHachureLines(lines);\n}\nexport function hachureEllipseFill(cx, cy, width, height) {\n  const helper = {\n    randOffset(x, _o) {\n      return _getOffset(-x, x);\n    }\n\n  };\n  const lines = hachureLinesForEllipse(helper, cx, cy, width, height, options);\n  return renderHachureLines(lines);\n}","map":null,"metadata":{},"sourceType":"module"}