{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/cristina/Desktop/BERKELEY/react-portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral([\"\\n    <div id=\\\"mirror\\\" class=\\\"mirror-text\\\">&#160;</div>\\n    <div class=\\\"fit\\\">\\n      <textarea id=\\\"textarea\\\" autocomplete=\\\"\", \"\\\" ?autofocus=\\\"\", \"\\\" inputmode=\\\"\", \"\\\"\\n        placeholder=\\\"\", \"\\\" ?readonly=\\\"\", \"\\\" ?required=\\\"\", \"\\\" ?disabled=\\\"\", \"\\\"\\n        rows=\\\"\", \"\\\" minlength=\\\"\", \"\\\" maxlength=\\\"\", \"\\\" @input=\\\"\", \"\\\"></textarea>\\n    </div>\\n    <div class=\\\"fit overlay\\\">\\n      <svg id=\\\"svg\\\"></svg>\\n    </div>\\n    \"]);\n\n  _templateObject2 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n    :host {\\n      display: inline-block;\\n      position: relative;\\n      font-family: sans-serif;\\n      width: 400px;\\n      outline: none;\\n      opacity: 0;\\n    }\\n\\n    :host(.wired-rendered) {\\n      opacity: 1;\\n    }\\n  \\n    :host(.wired-disabled) {\\n      opacity: 0.6 !important;\\n      cursor: default;\\n      pointer-events: none;\\n    }\\n  \\n    :host(.wired-disabled) svg {\\n      background: rgba(0, 0, 0, 0.07);\\n    }\\n  \\n    .fit {\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      right: 0;\\n      bottom: 0;\\n    }\\n  \\n    .overlay {\\n      pointer-events: none;\\n    }\\n  \\n    svg {\\n      display: block;\\n    }\\n  \\n    path {\\n      stroke: currentColor;\\n      stroke-width: 0.7;\\n      fill: transparent;\\n    }\\n  \\n    .mirror-text {\\n      visibility: hidden;\\n      word-wrap: break-word;\\n    }\\n\\n    #mirror {\\n      padding: 10px;\\n    }\\n  \\n    textarea {\\n      position: relative;\\n      outline: none;\\n      border: none;\\n      resize: none;\\n      background: inherit;\\n      color: inherit;\\n      width: 100%;\\n      height: 100%;\\n      font-size: inherit;\\n      font-family: inherit;\\n      line-height: inherit;\\n      text-align: inherit;\\n      padding: 10px;\\n      box-sizing: border-box;\\n    }\\n    \"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nimport { WiredBase, customElement, property, html, css } from 'wired-lib/lib/wired-base';\nimport { rectangle } from 'wired-lib';\nlet WiredTextarea = class WiredTextarea extends WiredBase {\n  constructor() {\n    super(...arguments);\n    this.rows = 1;\n    this.maxrows = 0;\n    this.autocomplete = '';\n    this.autofocus = false;\n    this.disabled = false;\n    this.inputmode = '';\n    this.placeholder = '';\n    this.required = false;\n    this.readonly = false;\n    this.tokens = [];\n    this.prevHeight = 0;\n  }\n\n  static get styles() {\n    return css(_templateObject());\n  }\n\n  render() {\n    return html(_templateObject2(), this.autocomplete, this.autofocus, this.inputmode, this.placeholder, this.readonly, this.required, this.disabled, this.rows, this.minlength, this.maxlength, this.onInput);\n  }\n\n  createRenderRoot() {\n    return this.attachShadow({\n      mode: 'open',\n      delegatesFocus: true\n    });\n  }\n\n  get textarea() {\n    if (this.shadowRoot) {\n      return this.shadowRoot.getElementById('textarea');\n    }\n\n    return null;\n  }\n\n  get mirror() {\n    return this.shadowRoot.getElementById('mirror');\n  }\n\n  get value() {\n    const input = this.textarea;\n    return input && input.value || '';\n  }\n\n  set value(v) {\n    const textarea = this.textarea;\n\n    if (!textarea) {\n      return;\n    }\n\n    if (textarea.value !== v) {\n      textarea.value = v || '';\n    }\n\n    this.mirror.innerHTML = this.valueForMirror();\n    this.requestUpdate();\n  }\n\n  valueForMirror() {\n    const input = this.textarea;\n\n    if (!input) {\n      return '';\n    }\n\n    this.tokens = input && input.value ? input.value.replace(/&/gm, '&amp;').replace(/\"/gm, '&quot;').replace(/'/gm, '&#39;').replace(/</gm, '&lt;').replace(/>/gm, '&gt;').split('\\n') : [''];\n    return this.constrain(this.tokens);\n  }\n\n  constrain(tokens) {\n    let _tokens;\n\n    tokens = tokens || [''];\n\n    if (this.maxrows > 0 && tokens.length > this.maxrows) {\n      _tokens = tokens.slice(0, this.maxrows);\n    } else {\n      _tokens = tokens.slice(0);\n    }\n\n    while (this.rows > 0 && _tokens.length < this.rows) {\n      _tokens.push('');\n    }\n\n    return _tokens.join('<br/>') + '&#160;';\n  }\n\n  refreshDisabledState() {\n    if (this.disabled) {\n      this.classList.add('wired-disabled');\n    } else {\n      this.classList.remove('wired-disabled');\n    }\n  }\n\n  firstUpdated() {\n    this.value = this.value || this.getAttribute('value') || '';\n  }\n\n  updated(changed) {\n    if (changed.has('disabled')) {\n      this.refreshDisabledState();\n    }\n\n    const svg = this.shadowRoot.getElementById('svg');\n    const s = this.getBoundingClientRect();\n\n    if (this.prevHeight !== s.height) {\n      while (svg.hasChildNodes()) {\n        svg.removeChild(svg.lastChild);\n      }\n\n      svg.setAttribute('width', \"\".concat(s.width));\n      svg.setAttribute('height', \"\".concat(s.height));\n      rectangle(svg, 2, 2, s.width - 2, s.height - 2);\n      this.prevHeight = s.height;\n      this.classList.add('wired-rendered');\n      this.updateCached();\n    }\n  }\n\n  updateCached() {\n    this.mirror.innerHTML = this.constrain(this.tokens);\n  }\n\n  onInput() {\n    this.value = this.textarea.value;\n  }\n\n};\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"rows\", void 0);\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"maxrows\", void 0);\n\n__decorate([property({\n  type: String\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"autocomplete\", void 0);\n\n__decorate([property({\n  type: Boolean\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"autofocus\", void 0);\n\n__decorate([property({\n  type: Boolean,\n  reflect: true\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"disabled\", void 0);\n\n__decorate([property({\n  type: String\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"inputmode\", void 0);\n\n__decorate([property({\n  type: String\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"placeholder\", void 0);\n\n__decorate([property({\n  type: Boolean\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"required\", void 0);\n\n__decorate([property({\n  type: Boolean\n}), __metadata(\"design:type\", Object)], WiredTextarea.prototype, \"readonly\", void 0);\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Number)], WiredTextarea.prototype, \"minlength\", void 0);\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Number)], WiredTextarea.prototype, \"maxlength\", void 0);\n\nWiredTextarea = __decorate([customElement('wired-textarea')], WiredTextarea);\nexport { WiredTextarea };","map":null,"metadata":{},"sourceType":"module"}