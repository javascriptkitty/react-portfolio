{"ast":null,"code":"import { Segment } from '../geometry';\nimport { HachureIterator } from '../utils/hachure';\nexport function lineLength(line) {\n  const p1 = line[0];\n  const p2 = line[1];\n  return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\nexport function getIntersectingLines(line, points) {\n  const intersections = [];\n  const s1 = new Segment([line[0], line[1]], [line[2], line[3]]);\n\n  for (let i = 0; i < points.length; i++) {\n    const s2 = new Segment(points[i], points[(i + 1) % points.length]);\n\n    if (s1.intersects(s2)) {\n      intersections.push([s1.xi, s1.yi]);\n    }\n  }\n\n  return intersections;\n}\nexport function affine(x, y, cx, cy, sinAnglePrime, cosAnglePrime, R) {\n  const A = -cx * cosAnglePrime - cy * sinAnglePrime + cx;\n  const B = R * (cx * sinAnglePrime - cy * cosAnglePrime) + cy;\n  const C = cosAnglePrime;\n  const D = sinAnglePrime;\n  const E = -R * sinAnglePrime;\n  const F = R * cosAnglePrime;\n  return [A + C * x + D * y, B + E * x + F * y];\n}\nexport function hachureLinesForPolygon(points, o) {\n  const ret = [];\n\n  if (points && points.length) {\n    let left = points[0][0];\n    let right = points[0][0];\n    let top = points[0][1];\n    let bottom = points[0][1];\n\n    for (let i = 1; i < points.length; i++) {\n      left = Math.min(left, points[i][0]);\n      right = Math.max(right, points[i][0]);\n      top = Math.min(top, points[i][1]);\n      bottom = Math.max(bottom, points[i][1]);\n    }\n\n    const angle = o.hachureAngle;\n    let gap = o.hachureGap;\n\n    if (gap < 0) {\n      gap = o.strokeWidth * 4;\n    }\n\n    gap = Math.max(gap, 0.1);\n    const radPerDeg = Math.PI / 180;\n    const hachureAngle = angle % 180 * radPerDeg;\n    const cosAngle = Math.cos(hachureAngle);\n    const sinAngle = Math.sin(hachureAngle);\n    const tanAngle = Math.tan(hachureAngle);\n    const it = new HachureIterator(top - 1, bottom + 1, left - 1, right + 1, gap, sinAngle, cosAngle, tanAngle);\n    let rect;\n\n    while ((rect = it.nextLine()) != null) {\n      const lines = getIntersectingLines(rect, points);\n\n      for (let i = 0; i < lines.length; i++) {\n        if (i < lines.length - 1) {\n          const p1 = lines[i];\n          const p2 = lines[i + 1];\n          ret.push([p1, p2]);\n        }\n      }\n    }\n  }\n\n  return ret;\n}\nexport function hachureLinesForEllipse(helper, cx, cy, width, height, o) {\n  const ret = [];\n  let rx = Math.abs(width / 2);\n  let ry = Math.abs(height / 2);\n  rx += helper.randOffset(rx * 0.05, o);\n  ry += helper.randOffset(ry * 0.05, o);\n  const angle = o.hachureAngle;\n  let gap = o.hachureGap;\n\n  if (gap <= 0) {\n    gap = o.strokeWidth * 4;\n  }\n\n  let fweight = o.fillWeight;\n\n  if (fweight < 0) {\n    fweight = o.strokeWidth / 2;\n  }\n\n  const radPerDeg = Math.PI / 180;\n  const hachureAngle = angle % 180 * radPerDeg;\n  const tanAngle = Math.tan(hachureAngle);\n  const aspectRatio = ry / rx;\n  const hyp = Math.sqrt(aspectRatio * tanAngle * aspectRatio * tanAngle + 1);\n  const sinAnglePrime = aspectRatio * tanAngle / hyp;\n  const cosAnglePrime = 1 / hyp;\n  const gapPrime = gap / (rx * ry / Math.sqrt(ry * cosAnglePrime * (ry * cosAnglePrime) + rx * sinAnglePrime * (rx * sinAnglePrime)) / rx);\n  let halfLen = Math.sqrt(rx * rx - (cx - rx + gapPrime) * (cx - rx + gapPrime));\n\n  for (let xPos = cx - rx + gapPrime; xPos < cx + rx; xPos += gapPrime) {\n    halfLen = Math.sqrt(rx * rx - (cx - xPos) * (cx - xPos));\n    const p1 = affine(xPos, cy - halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n    const p2 = affine(xPos, cy + halfLen, cx, cy, sinAnglePrime, cosAnglePrime, aspectRatio);\n    ret.push([p1, p2]);\n  }\n\n  return ret;\n}","map":null,"metadata":{},"sourceType":"module"}