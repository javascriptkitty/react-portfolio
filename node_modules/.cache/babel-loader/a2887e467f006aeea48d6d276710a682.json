{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/cristina/Desktop/BERKELEY/react-portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral([\"\\n    <div id=\\\"container\\\" style=\\\"display: none;\\\">\\n      <div class=\\\"overlay\\\">\\n        <svg id=\\\"svg\\\"></svg>\\n      </div>\\n      <span style=\\\"position: relative;\\\">\", \"</span>\\n    </div>\\n    \"]);\n\n  _templateObject2 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n    :host {\\n      display: block;\\n      position: absolute;\\n      outline: none;\\n      z-index: 1002;\\n      -moz-user-select: none;\\n      -ms-user-select: none;\\n      -webkit-user-select: none;\\n      user-select: none;\\n      cursor: default;\\n      font-family: inherit;\\n      font-size: 9pt;\\n      line-height: 1;\\n    }\\n  \\n    .overlay {\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      right: 0;\\n      bottom: 0;\\n      pointer-events: none;\\n    }\\n  \\n    svg {\\n      display: block;\\n    }\\n  \\n    path {\\n      stroke-width: 0.7;\\n      stroke: var(--wired-tooltip-border-color, currentColor);\\n      fill: var(--wired-tooltip-background, rgba(255, 255, 255, 0.9));\\n    }\\n  \\n    #container {\\n      position: relative;\\n      padding: 8px;\\n    }\\n    \"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nimport { WiredBase, customElement, property, html, css } from 'wired-lib/lib/wired-base';\nimport { polygon } from 'wired-lib';\nlet WiredTooltip = class WiredTooltip extends WiredBase {\n  constructor() {\n    super(...arguments);\n    this.offset = 14;\n    this.position = 'bottom';\n    this.dirty = false;\n    this.showing = false;\n    this._target = null;\n    this.showHandler = this.show.bind(this);\n    this.hideHandler = this.hide.bind(this);\n  }\n\n  static get styles() {\n    return css(_templateObject());\n  }\n\n  render() {\n    return html(_templateObject2(), this.text);\n  }\n\n  get target() {\n    if (this._target) {\n      return this._target;\n    }\n\n    const parent = this.parentNode;\n    const owner = (this.getRootNode ? this.getRootNode() : null) || document;\n    let t = null;\n\n    if (this.for) {\n      t = owner.querySelector('#' + this.for);\n    } else if (parent) {\n      t = parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? owner.host : parent;\n    }\n\n    return t;\n  }\n\n  detachListeners() {\n    if (this._target) {\n      this._target.removeEventListener('mouseenter', this.showHandler);\n\n      this._target.removeEventListener('focus', this.showHandler);\n\n      this._target.removeEventListener('mouseleave', this.hideHandler);\n\n      this._target.removeEventListener('blur', this.hideHandler);\n\n      this._target.removeEventListener('click', this.hideHandler);\n    }\n\n    this.removeEventListener('mouseenter', this.hideHandler);\n  }\n\n  attachListeners() {\n    if (this._target) {\n      this._target.addEventListener('mouseenter', this.showHandler);\n\n      this._target.addEventListener('focus', this.showHandler);\n\n      this._target.addEventListener('mouseleave', this.hideHandler);\n\n      this._target.addEventListener('blur', this.hideHandler);\n\n      this._target.addEventListener('click', this.hideHandler);\n    }\n\n    this.addEventListener('mouseenter', this.hideHandler);\n  }\n\n  refreshTarget() {\n    this.detachListeners();\n    this._target = null;\n    this._target = this.target;\n    this.attachListeners();\n    this.dirty = true;\n  }\n\n  layout() {\n    const svg = this.shadowRoot.getElementById('svg');\n\n    while (svg.hasChildNodes()) {\n      svg.removeChild(svg.lastChild);\n    }\n\n    const s = this.getBoundingClientRect();\n    let w = s.width;\n    let h = s.height;\n\n    switch (this.position) {\n      case 'left':\n      case 'right':\n        w = w + this.offset;\n        break;\n\n      default:\n        h = h + this.offset;\n        break;\n    }\n\n    svg.setAttribute('width', \"\".concat(w));\n    svg.setAttribute('height', \"\".concat(h));\n    let points = [];\n\n    switch (this.position) {\n      case 'top':\n        points = [[2, 2], [w - 2, 2], [w - 2, h - this.offset], [w / 2 + 8, h - this.offset], [w / 2, h - this.offset + 8], [w / 2 - 8, h - this.offset], [0, h - this.offset]];\n        break;\n\n      case 'left':\n        points = [[2, 2], [w - this.offset, 2], [w - this.offset, h / 2 - 8], [w - this.offset + 8, h / 2], [w - this.offset, h / 2 + 8], [w - this.offset, h], [2, h - 2]];\n        break;\n\n      case 'right':\n        points = [[this.offset, 2], [w - 2, 2], [w - 2, h - 2], [this.offset, h - 2], [this.offset, h / 2 + 8], [this.offset - 8, h / 2], [this.offset, h / 2 - 8]];\n        svg.style.transform = \"translateX(\".concat(-this.offset, \"px)\");\n        break;\n\n      default:\n        points = [[2, this.offset], [0, h - 2], [w - 2, h - 2], [w - 2, this.offset], [w / 2 + 8, this.offset], [w / 2, this.offset - 8], [w / 2 - 8, this.offset]];\n        svg.style.transform = \"translateY(\".concat(-this.offset, \"px)\");\n        break;\n    }\n\n    polygon(svg, points);\n    this.dirty = false;\n  }\n\n  firstUpdated() {\n    this.layout();\n  }\n\n  updated(changedProps) {\n    if (changedProps.has('position') || changedProps.has('text')) {\n      this.dirty = true;\n    }\n\n    if (!this._target || changedProps.has('for')) {\n      this.refreshTarget();\n    }\n\n    if (this.dirty) {\n      this.layout();\n    }\n  }\n\n  show() {\n    if (this.showing) {\n      return;\n    }\n\n    this.showing = true;\n    this.shadowRoot.getElementById('container').style.display = '';\n    this.updatePosition();\n    setTimeout(() => {\n      this.layout();\n    }, 1);\n  }\n\n  hide() {\n    if (!this.showing) {\n      return;\n    }\n\n    this.showing = false;\n    this.shadowRoot.getElementById('container').style.display = 'none';\n  }\n\n  updatePosition() {\n    if (!this._target || !this.offsetParent) {\n      return;\n    }\n\n    const offset = this.offset;\n    const parentRect = this.offsetParent.getBoundingClientRect();\n\n    const targetRect = this._target.getBoundingClientRect();\n\n    const tipRect = this.getBoundingClientRect();\n    const horizontalCenterOffset = (targetRect.width - tipRect.width) / 2;\n    const verticalCenterOffset = (targetRect.height - tipRect.height) / 2;\n    const targetLeft = targetRect.left - parentRect.left;\n    const targetTop = targetRect.top - parentRect.top;\n    let tooltipLeft, tooltipTop;\n\n    switch (this.position) {\n      case 'top':\n        tooltipLeft = targetLeft + horizontalCenterOffset;\n        tooltipTop = targetTop - tipRect.height - offset;\n        break;\n\n      case 'bottom':\n        tooltipLeft = targetLeft + horizontalCenterOffset;\n        tooltipTop = targetTop + targetRect.height + offset;\n        break;\n\n      case 'left':\n        tooltipLeft = targetLeft - tipRect.width - offset;\n        tooltipTop = targetTop + verticalCenterOffset;\n        break;\n\n      case 'right':\n        tooltipLeft = targetLeft + targetRect.width + offset;\n        tooltipTop = targetTop + verticalCenterOffset;\n        break;\n    }\n\n    this.style.left = tooltipLeft + 'px';\n    this.style.top = tooltipTop + 'px';\n  }\n\n};\n\n__decorate([property({\n  type: String\n}), __metadata(\"design:type\", String)], WiredTooltip.prototype, \"for\", void 0);\n\n__decorate([property({\n  type: String\n}), __metadata(\"design:type\", String)], WiredTooltip.prototype, \"text\", void 0);\n\n__decorate([property({\n  type: Number\n}), __metadata(\"design:type\", Object)], WiredTooltip.prototype, \"offset\", void 0);\n\n__decorate([property({\n  type: String\n}), __metadata(\"design:type\", String)], WiredTooltip.prototype, \"position\", void 0);\n\nWiredTooltip = __decorate([customElement('wired-tooltip')], WiredTooltip);\nexport { WiredTooltip };","map":null,"metadata":{},"sourceType":"module"}