{"ast":null,"code":"import _taggedTemplateLiteral from \"/Users/cristina/Desktop/BERKELEY/react-portfolio/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral([\"\\n    <slot id=\\\"slot\\\" @slotchange=\\\"\", \"\\\"></slot>\\n    <div class=\\\"overlay\\\">\\n      <svg id=\\\"svg\\\"></svg>\\n    </div>\\n    \"]);\n\n  _templateObject2 = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n    :host {\\n      display: inline-block;\\n      font-family: inherit;\\n      position: relative;\\n      padding: 5px;\\n      outline: none;\\n      opacity: 0;\\n    }\\n\\n    :host(.wired-rendered) {\\n      opacity: 1;\\n    }\\n\\n    :host(:focus) path {\\n      stroke-width: 1.5;\\n    }\\n  \\n    .overlay {\\n      position: absolute;\\n      top: 0;\\n      left: 0;\\n      right: 0;\\n      bottom: 0;\\n      pointer-events: none;\\n    }\\n  \\n    svg {\\n      display: block;\\n    }\\n  \\n    path {\\n      stroke: currentColor;\\n      stroke-width: 0.7;\\n      fill: transparent;\\n    }\\n\\n    ::slotted(wired-item) {\\n      display: block;\\n    }\\n\\n    :host(.wired-horizontal) ::slotted(wired-item) {\\n      display: inline-block;\\n    }\\n    \"]);\n\n  _templateObject = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nimport { WiredBase, customElement, property, html, css } from 'wired-lib/lib/wired-base';\nimport { rectangle } from 'wired-lib';\nimport 'wired-item';\nlet WiredListbox = class WiredListbox extends WiredBase {\n  constructor() {\n    super(...arguments);\n    this.horizontal = false;\n    this.itemNodes = [];\n    this.itemClickHandler = this.onItemClick.bind(this);\n  }\n\n  static get styles() {\n    return css(_templateObject());\n  }\n\n  render() {\n    return html(_templateObject2(), () => this.requestUpdate());\n  }\n\n  firstUpdated() {\n    this.setAttribute('role', 'listbox');\n    this.tabIndex = +(this.getAttribute('tabindex') || 0);\n    this.refreshSelection();\n    this.addEventListener('click', this.itemClickHandler);\n    this.addEventListener('keydown', event => {\n      switch (event.keyCode) {\n        case 37:\n        case 38:\n          event.preventDefault();\n          this.selectPrevious();\n          break;\n\n        case 39:\n        case 40:\n          event.preventDefault();\n          this.selectNext();\n          break;\n      }\n    });\n  }\n\n  updated() {\n    const svg = this.shadowRoot.getElementById('svg');\n\n    while (svg.hasChildNodes()) {\n      svg.removeChild(svg.lastChild);\n    }\n\n    const s = this.getBoundingClientRect();\n    svg.setAttribute('width', \"\".concat(s.width));\n    svg.setAttribute('height', \"\".concat(s.height));\n    rectangle(svg, 0, 0, s.width, s.height);\n    this.classList.add('wired-rendered');\n\n    if (this.horizontal) {\n      this.classList.add('wired-horizontal');\n    } else {\n      this.classList.remove('wired-horizontal');\n    }\n\n    if (!this.itemNodes.length) {\n      this.itemNodes = [];\n      const nodes = this.shadowRoot.getElementById('slot').assignedNodes();\n\n      if (nodes && nodes.length) {\n        for (let i = 0; i < nodes.length; i++) {\n          const element = nodes[i];\n\n          if (element.tagName === 'WIRED-ITEM') {\n            element.setAttribute('role', 'option');\n            this.itemNodes.push(element);\n          }\n        }\n      }\n    }\n  }\n\n  onItemClick(event) {\n    event.stopPropagation();\n    this.selected = event.target.value;\n    this.refreshSelection();\n    this.fireSelected();\n  }\n\n  refreshSelection() {\n    if (this.lastSelectedItem) {\n      this.lastSelectedItem.selected = false;\n      this.lastSelectedItem.removeAttribute('aria-selected');\n    }\n\n    const slot = this.shadowRoot.getElementById('slot');\n    const nodes = slot.assignedNodes();\n\n    if (nodes) {\n      let selectedItem = null;\n\n      for (let i = 0; i < nodes.length; i++) {\n        const element = nodes[i];\n\n        if (element.tagName === 'WIRED-ITEM') {\n          const value = element.value || '';\n\n          if (this.selected && value === this.selected) {\n            selectedItem = element;\n            break;\n          }\n        }\n      }\n\n      this.lastSelectedItem = selectedItem || undefined;\n\n      if (this.lastSelectedItem) {\n        this.lastSelectedItem.selected = true;\n        this.lastSelectedItem.setAttribute('aria-selected', 'true');\n      }\n\n      if (selectedItem) {\n        this.value = {\n          value: selectedItem.value || '',\n          text: selectedItem.textContent || ''\n        };\n      } else {\n        this.value = undefined;\n      }\n    }\n  }\n\n  fireSelected() {\n    this.fireEvent('selected', {\n      selected: this.selected\n    });\n  }\n\n  selectPrevious() {\n    const list = this.itemNodes;\n\n    if (list.length) {\n      let index = -1;\n\n      for (let i = 0; i < list.length; i++) {\n        if (list[i] === this.lastSelectedItem) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        index = 0;\n      } else if (index === 0) {\n        index = list.length - 1;\n      } else {\n        index--;\n      }\n\n      this.selected = list[index].value || '';\n      this.refreshSelection();\n      this.fireSelected();\n    }\n  }\n\n  selectNext() {\n    const list = this.itemNodes;\n\n    if (list.length) {\n      let index = -1;\n\n      for (let i = 0; i < list.length; i++) {\n        if (list[i] === this.lastSelectedItem) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        index = 0;\n      } else if (index >= list.length - 1) {\n        index = 0;\n      } else {\n        index++;\n      }\n\n      this.selected = list[index].value || '';\n      this.refreshSelection();\n      this.fireSelected();\n    }\n  }\n\n};\n\n__decorate([property({\n  type: Object\n}), __metadata(\"design:type\", Object)], WiredListbox.prototype, \"value\", void 0);\n\n__decorate([property({\n  type: String\n}), __metadata(\"design:type\", String)], WiredListbox.prototype, \"selected\", void 0);\n\n__decorate([property({\n  type: Boolean\n}), __metadata(\"design:type\", Object)], WiredListbox.prototype, \"horizontal\", void 0);\n\nWiredListbox = __decorate([customElement('wired-listbox')], WiredListbox);\nexport { WiredListbox };","map":null,"metadata":{},"sourceType":"module"}